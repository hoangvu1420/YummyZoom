\documentclass[../DoAn.tex]{subfiles}
\begin{document}

\section{Thiết kế kiến trúc}
\subsection{Lựa chọn kiến trúc phần mềm}
\label{subsec:4.1.1}

Dựa trên các yêu cầu nghiệp vụ phức tạp của hệ thống YummyZoom, đặc biệt là tính năng đặt hàng nhóm (TeamCart) với yêu cầu về tính nhất quán dữ liệu cao và khả năng xử lý đồng thời, đồ án lựa chọn áp dụng kiến trúc \textbf{Clean Architecture} (Kiến trúc Sạch) kết hợp với tư duy thiết kế \textbf{Domain-Driven Design (DDD)}. Về mặt triển khai, hệ thống được xây dựng theo mô hình \textbf{Monolithic Modular} (Đơn khối module hóa).

\subsubsection{Mô hình kiến trúc tổng thể}
Thay vì lựa chọn kiến trúc Microservices ngay từ đầu - vốn đòi hỏi chi phí vận hành và quản lý hạ tầng lớn, hay kiến trúc Layered (3 lớp) truyền thống dễ gây ra sự phụ thuộc chặt chẽ vào cơ sở dữ liệu, nhóm phát triển quyết định sử dụng mô hình Monolithic Modular.

Mô hình này giúp cân bằng giữa tốc độ phát triển và khả năng mở rộng:
\begin{itemize}
    \item \textbf{Phát triển nhanh và nhất quán:} Toàn bộ mã nguồn nằm trong một Solution thống nhất, giúp việc gỡ lỗi (debug), kiểm thử và tái cấu trúc (refactor) trở nên dễ dàng hơn.
    \item \textbf{Ranh giới nghiệp vụ rõ ràng (Modular Boundaries):} Các module được tổ chức độc lập về mặt logic dựa trên các Bounded Contexts. Điều này tạo tiền đề vững chắc để tách thành các Microservices riêng biệt khi hệ thống cần mở rộng quy mô trong tương lai mà không làm phá vỡ cấu trúc hiện tại.
    \item \textbf{Tập trung vào nghiệp vụ cốt lõi:} Clean Architecture giúp cô lập logic nghiệp vụ (Domain) khỏi các yếu tố thay đổi thường xuyên như giao diện người dùng (UI) hay công nghệ lưu trữ (Database).
\end{itemize}

\subsubsection{Tổ chức các tầng kiến trúc (Layered Architecture)}
Hệ thống tuân thủ nghiêm ngặt quy tắc phụ thuộc (Dependency Rule) của Clean Architecture: "Mọi sự phụ thuộc của mã nguồn chỉ được hướng vào bên trong". Cấu trúc dự án được ánh xạ từ lý thuyết vào thực tế như sau:

\begin{enumerate}
    \item \textbf{Tầng Miền (Domain Layer) - \textit{Project: YummyZoom.Domain}}
    \newline Đây là lõi trung tâm của hệ thống, nơi chứa các quy tắc nghiệp vụ bất biến của doanh nghiệp. Tầng này hoàn toàn không phụ thuộc vào bất kỳ thư viện bên ngoài hay công nghệ cơ sở dữ liệu nào.
    \begin{itemize}
        \item \textbf{Thành phần:} Entities (Thực thể), Value Objects (Đối tượng giá trị), Aggregates (Hợp nhất), Domain Events.
        \item \textbf{Ví dụ thực tế:} Aggregate \texttt{TeamCart} đóng gói logic nghiệp vụ của giỏ hàng nhóm, đảm bảo các quy tắc như: một giỏ hàng chỉ có một chủ phòng (Host), và chỉ Host mới có quyền chốt đơn hoặc khóa giỏ hàng.
    \end{itemize}

    \item \textbf{Tầng Ứng dụng (Application Layer) - \textit{Project: YummyZoom.Application}}
    \newline Đóng vai trò lớp vỏ bao quanh Domain, điều phối các yêu cầu từ người dùng và chuyển đổi chúng thành các thao tác nghiệp vụ.
    \begin{itemize}
        \item \textbf{Thành phần:} Use Cases (được triển khai dưới dạng Command/Query Handlers), Validators (Kiểm tra dữ liệu), Interfaces cho Infrastructure.
        \item \textbf{Ví dụ thực tế:} AddItemToTeamCartCommand là một Use Case nhận yêu cầu thêm món, kích hoạt phương thức AddItem trong Domain Entity, và sau đó lưu thay đổi thông qua ITeamCartRepository.
    \end{itemize}

    \item \textbf{Tầng Hạ tầng (Infrastructure Layer) - \textit{Project: YummyZoom.Infrastructure}}
    \newline Nơi chưa các thực thi của các interfaces kỹ thuật được định nghĩa ở tầng Application. Đây là nơi các công nghệ cụ thể được "cắm" vào hệ thống.
    \begin{itemize}
        \item \textbf{Thành phần:} DbContext (Entity Framework Core), Repositories Implementation, Services giao tiếp bên ngoài (EmailService, CloudinaryService, StripeService, FCMService).
        \item \textbf{Chức năng:} Truy xuất dữ liệu từ SQL Server/PostgreSQL, tương tác với hệ thống file, gửi email xác nhận, xử lý thanh toán qua Stripe, gửi thông báo đẩy với FCM.
    \end{itemize}

    \item \textbf{Tầng Giao diện/Trình bày (Web/Presentation Layer) - \textit{Project: YummyZoom.Web}}
    \newline Lớp vỏ ngoài cùng, chịu trách nhiệm giao tiếp với Client (Mobile App, Web Admin).
    \begin{itemize}
        \item \textbf{Thành phần:} Minimal APIs, SignalR Hubs, Middlewares.
        \item \textbf{Nhiệm vụ:} Nhận HTTP Request, xác thực token, gọi xuống Application Layer để xử lý và trả về HTTP Response chuẩn (JSON).
    \end{itemize}
\end{enumerate}

\subsubsection{Thiết kế chiến lược (Strategic Design)}
Áp dụng chiến lược của DDD, hệ thống được chia nhỏ thành các \textbf{Bounded Contexts} (Ngữ cảnh giới hạn), mỗi context giải quyết một vấn đề nghiệp vụ cụ thể và có Ubiquitous Language (Ngôn ngữ chung) riêng:
\begin{itemize}
    \item \textbf{Identity Context:} Quản lý người dùng, phân quyền và xác thực (Authentication/Authorization).
    \item \textbf{Catalog Context:} Quản lý thực đơn, danh mục, thông tin nhà hàng, món ăn và các tùy chọn (Toppings).
    \item \textbf{TeamCart Context:} Ngữ cảnh quan trọng và phức tạp nhất, xử lý logic chia sẻ giỏ hàng, đồng bộ trạng thái thời gian thực và phân chia hóa đơn.
    \item \textbf{Ordering Context:} Xử lý quy trình đặt hàng, thanh toán và vòng đời của đơn hàng sau khi được chốt.
\end{itemize}

\subsubsection{Các mẫu kỹ thuật chủ đạo (Tactical Patterns)}
Để tối ưu hóa hiệu năng và khả năng bảo trì, hệ thống áp dụng các mẫu thiết kế kỹ thuật nâng cao:

\paragraph{CQRS (Command Query Responsibility Segregation):}
Hệ thống tách biệt rõ ràng luồng Đọc (Query) và Ghi (Command) dữ liệu:
\begin{itemize}
    \item \textbf{Phần Ghi (Write Side):} Sử dụng \textbf{Entity Framework Core} kết hợp với Domain Model để đảm bảo tính toàn vẹn và nhất quán dữ liệu (Data Consistency) khi thực hiện các thay đổi nghiệp vụ.
    \item \textbf{Phần Đọc (Read Side):} Sử dụng \textbf{Dapper} với SQL để truy vấn dữ liệu trực tiếp và trả về các DTO phẳng. Đồng thời, hệ thống kết hợp sử dụng các \textbf{Read Models} được cập nhật song song với các bảng ghi, giúp tránh việc thực hiện các phép JOIN bảng quá mức. Cách tiếp cận này đảm bảo khả năng phục vụ hiệu quả các yêu cầu dữ liệu phức tạp từ ứng dụng người dùng với tốc độ phản hồi tối ưu.
\end{itemize}

\paragraph{Domain Events \& Outbox Pattern:}
Giải quyết bài toán về tính nhất quán cuối cùng (Eventual Consistency) và xử lý bất đồng bộ:
\begin{itemize}
    \item \textbf{Cơ chế:} Khi một nghiệp vụ quan trọng hoàn tất (ví dụ: \texttt{OrderCreated}), hệ thống không gọi trực tiếp các dịch vụ bên thứ ba (như gửi email) mà sinh ra một \texttt{Domain Event}. Event này được lưu vào bảng \texttt{OutboxMessages} trong cùng một transaction database với dữ liệu chính.
    \item \textbf{Tác dụng:} Một tiến trình nền (Background Worker) sẽ đọc bảng Outbox và thực hiện các tác vụ phụ sau đó. Điều này đảm bảo rằng giao dịch chính luôn nhanh và an toàn; nếu việc gửi email thất bại, nó sẽ được thử lại (Retry) mà không làm mất đơn hàng.
\end{itemize}

\subsubsection{Kết luận}
Việc lựa chọn kiến trúc Clean Architecture kết hợp DDD và CQRS mang lại nền tảng vững chắc cho hệ thống YummyZoom. Kiến trúc này không chỉ giải quyết tốt các bài toán nghiệp vụ phức tạp hiện tại về đặt hàng nhóm mà còn đảm bảo các tiêu chí phi chức năng quan trọng: dễ dàng kiểm thử (Testability), dễ bảo trì (Maintainability) và sẵn sàng mở rộng (Scalability) trong tương lai.

\subsection{Thiết kế tổng quan}
Biểu đồ gói tổng quan của hệ thống YummyZoom thể hiện sự phân tầng rõ ràng và các ràng buộc phụ thuộc tuân thủ quy tắc Clean Architecture. 
\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{Hinhve/package_overview.png}
    \caption{Biểu đồ phụ thuộc gói tổng quan YummyZoom (Backend)}
    \label{fig:FigPackageOverview}
\end{figure}

\subsection{Thiết kế chi tiết gói}
Mục tiêu của phần này là minh họa chi tiết cách tổ chức mã nguồn và hiện thực hóa kiến trúc Clean Architecture thông qua các biểu đồ gói (Package Diagrams). Tôi đã lựa chọn 2 luồng nghiệp vụ tiêu biểu đại diện cho hai phân hệ quan trọng nhất: Restaurant (Nhà hàng) và Order (Đơn hàng) để phân tích.

Các biểu đồ được xây dựng dựa trên các quy tắc sau nhằm đảm bảo tính trực quan và tránh sự quá tải thông tin do số lượng lớp lớn của hệ thống:
\begin{itemize}
    \item \textbf{Phạm vi:} Mỗi biểu đồ tập trung vào một luồng nghiệp vụ cụ thể (bao gồm 1 Command và 1 Query), không bao gồm toàn bộ các lớp trong mã nguồn.
    \item \textbf{Cấu trúc:} Các thành phần được vẽ và sắp xếp dọc theo 4 tầng của Clean Architecture (Web, Application, Domain, Infrastructure).
    \item \textbf{Chi tiết:} Chỉ thể hiện tên lớp và các mối quan hệ chính, lược bỏ các phương thức và thuộc tính chi tiết.
\end{itemize}

\subsubsection{Biểu đồ 1: Restaurant (Create Restaurant + Search Restaurants)}
Biểu đồ này minh họa luồng xử lý cho hai chức năng: Phê duyệt đăng ký nhà hàng (Create) và Tìm kiếm nhà hàng (Search).

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth,height=0.95\textheight,keepaspectratio]{Hinhve/package_restaurant_create_search.png}
    \caption{Biểu đồ gói chi tiết phân hệ Restaurant (Create \& Search)}
    \label{fig:PkgRestaurant}
\end{figure}

\noindent \textbf{Mô tả luồng logic:}
Biểu đồ thể hiện cách các tầng phối hợp để xử lý yêu cầu:
\begin{itemize}
    \item \textbf{Luồng Ghi (Command):} Bắt đầu từ yêu cầu POST đến Endpoints/RestaurantRegistrations để phê duyệt đăng ký nhà hàng, yêu cầu phê duyệt được chuyển đến ApproveRestaurantRegistrationCommandHandler (Application). Handler này tương tác với Domain (RestaurantAggregate, RestaurantRegistration) để đảm bảo quy tắc nghiệp vụ, rồi một đối tượng Restaurant được tạo và lưu trữ qua RestaurantRepository (Infrastructure) xuống database. Khi thành công, sự kiện RestaurantCreated được phát ra và được xử lý bởi RestaurantCreatedSearchHandler (Application) để cập nhật bảng SearchIndex trong database để phục phụ cho thao tác tìm kiếm sau này.
    \item \textbf{Luồng Đọc (Query):} Khi yêu cầu GET đến Restaurants để tìm kiếm nhà hàng theo các tiêu chí, SearchRestaurantsQueryHandler (Application) thực hiện truy vấn tối ưu bằng SQL vào bảng SearchIndex là một Read Model tối ưu hóa để phục vụ tìm kiếm. Dữ liệu phục vụ tìm kiếm được cập nhật bất đồng bộ bởi SearchIndexMaintainer (Infrastructure) ngay khi nhận được sự kiện RestaurantCreated, minh họa cho mô hình CQRS tách biệt Ghi và Đọc.
\end{itemize}

\subsubsection{Biểu đồ 2: Order (Initiate Order + Get Order Status)}
Biểu đồ này mô tả quy trình khởi tạo đơn hàng mới và truy vấn trạng thái đơn hàng, đóng vai trò cốt lõi trong giao dịch thương mại của hệ thống.

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth,height=0.95\textheight,keepaspectratio]{Hinhve/package_order_initiate_status.png}
    \caption{Biểu đồ gói chi tiết phân hệ Order (Initiate \& Status)}
    \label{fig:PkgOrder}
\end{figure}

\noindent \textbf{Mô tả luồng logic:}
Biểu đồ minh họa sự phối hợp chặt chẽ giữa các thành phần để xử lý đơn hàng:
\begin{itemize}
    \item \textbf{Luồng Ghi (Command):} Yêu cầu đặt hàng từ người dùng (Web Endpoints) được đóng gói thành InitiateOrderCommand. InitiateOrderCommandHandler đóng vai trò điều phối chính: nó sử dụng OrderFinancialService (một Domain Service) để tính toán chi phí, xác thực qua IPaymentGatewayService, và tương tác với các repositories (IOrderRepository, ICouponRepository) để lưu trữ Aggregate Order. Thành công kích hoạt sự kiện OrderPlaced, dẫn đến việc OrderPlacedEventHandler gọi các dịch vụ thông báo (IOrderRealtimeNotifier, IOrderPushNotifier).
    \item \textbf{Luồng Đọc (Query):} GetOrderStatusQueryHandler nhận truy vấn qua IDbConnectionFactory (Dapper) để lấy projection gọn của đơn hàng (OrderStatusDto). Handler kiểm tra quyền truy cập dựa trên IUser/claims (khách hàng hoặc nhân viên/owner nhà hàng), sau đó trả về trạng thái và mốc thời gian cập nhật, giúp client theo dõi tiến trình đơn hàng theo thời gian thực mà không tải dư dữ liệu.
\end{itemize}

\section{Thiết kế chi tiết}
\subsection{Thiết kế giao diện}
\subsubsection{Thiết kế giao diện ứng dụng di động dành cho khách hàng}
Ứng dụng di động được thiết kế hướng tới thiết bị 384x854 để đảm bảo tỷ lệ hiển thị thống nhất với cấu hình thiết kế, ưu tiên trải nghiệm đặt món nhanh và rõ ràng. Bố cục được tổ chức theo thứ bậc thông tin, tiêu đề và dữ liệu chính đặt ở vùng nhìn đầu tiên, các hành động quan trọng giữ vị trí nổi bật nhằm giảm thao tác thừa. Hệ thống kiểu chữ và kích thước chữ được quy đổi theo thang sp để bảo toàn độ đọc trên nhiều thiết bị, trong khi các thành phần nhập liệu và nút bấm thống nhất bán kính bo góc và khoảng đệm để tạo cảm giác thân thiện. Màu sắc thương hiệu (màu chính, màu phụ và màu nhấn) được chuẩn hóa trong ứng dụng, tuy nhiên bộ mockup được thể hiện theo tông đen trắng để tập trung vào cấu trúc và luồng thao tác, đồng thời phản hồi người dùng chủ yếu thông qua thông báo dạng thanh trượt ngắn gọn ở cuối màn hình.

Các màn hình tiêu biểu được lựa chọn nhằm phản ánh đầy đủ hành trình người dùng từ khám phá đến thanh toán, bao gồm trang Home/Menu và Restaurant Detail (Hình \ref{fig:mobile-home-restaurant}), cùng với trang TeamCart Lobby và Checkout/Payment (Hình \ref{fig:mobile-teamcart-checkout}).

\begin{figure}[H]
    \centering
    \includegraphics[width=0.48\textwidth]{Hinhve/mobile-home.png}
    \hfill
    \includegraphics[width=0.48\textwidth]{Hinhve/mobile-restaurant_detail.png}
    \caption{Minh hoạ màn hình Home/Menu (trái) và Restaurant Detail (phải) trên ứng dụng di động}
    \label{fig:mobile-home-restaurant}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.48\textwidth]{Hinhve/mobile-teamcart_lobby.png}
    \hfill
    \includegraphics[width=0.48\textwidth]{Hinhve/mobile-checkout_payment.png}
    \caption{Minh hoạ màn hình TeamCart Lobby (trái) và Checkout/Payment (phải) trên ứng dụng di động}
    \label{fig:mobile-teamcart-checkout}
\end{figure}

\subsubsection{Thiết kế giao diện hệ thống quản trị trên web}
Hệ thống quản trị hướng tới màn hình desktop 1440x900 với mật độ thông tin cao, đồng thời đảm bảo khả năng hiển thị trên tablet ngang. Bố cục ưu tiên khả năng quét nhanh dữ liệu với lưới khoảng cách theo bước nhỏ, các khối thông tin và bảng dữ liệu được sắp xếp gọn để phục vụ tác vụ điều hành. Kiểu chữ được phân cấp rõ ràng từ nhãn điều hướng đến tiêu đề trang, kết hợp các mức đậm khác nhau để nhấn mạnh số liệu quan trọng. Hệ màu thương hiệu được sử dụng cho hành động chính và trạng thái tương tác, trong khi phiên bản nền tối được hỗ trợ để cải thiện khả năng đọc ở môi trường ánh sáng yếu. Các thành phần nhập liệu, nút bấm và thông báo hệ thống được chuẩn hóa về viền, trạng thái tập trung và hiển thị lỗi nhằm giữ tính nhất quán trong các luồng nghiệp vụ.

Các màn hình minh họa tập trung vào những chức năng cốt lõi của quản trị, gồm trang Restaurant Dashboard (Hình \ref{fig:web-dashboard}), trang Live Orders (Hình \ref{fig:web-live-orders}), trang Quản lý thực đơn (Hình \ref{fig:web-menu-management}) và trang Duyệt đăng ký nhà hàng (Hình \ref{fig:web-approval}).

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{Hinhve/restaurant-dashboard-desktop.png}
    \caption{Minh hoạ màn hình Restaurant Dashboard trên hệ thống quản trị}
    \label{fig:web-dashboard}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{Hinhve/restaurant-live-orders-desktop.png}
    \caption{Minh hoạ màn hình Live Orders trên hệ thống quản trị}
    \label{fig:web-live-orders}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{Hinhve/restaurant-menu-management-desktop.png}
    \caption{Minh hoạ màn hình Quản lý thực đơn trên hệ thống quản trị}
    \label{fig:web-menu-management}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{Hinhve/admin-restaurant-registrations-desktop.png}
    \caption{Minh hoạ màn hình Duyệt đăng ký nhà hàng trên hệ thống quản trị}
    \label{fig:web-approval}
\end{figure}

\subsection{Thiết kế lớp}
Trong dự án YummyZoom, phần lớn quy tắc nghiệp vụ được đóng gói tại lớp miền (Domain layer) theo Clean Architecture, do đó phần thiết kế lớp tập trung vào các aggregate root tiêu biểu. Bốn lớp được lựa chọn gồm Order, TeamCart, Restaurant và MenuItem vì đây là các lớp chịu trách nhiệm quản lý vòng đời, trạng thái và các bất biến nghiệp vụ quan trọng của hệ thống. Đối với các lớp ở lớp ứng dụng (Application layer), nội dung chỉ trình bày ở mức vai trò điều phối luồng, bởi đa số các handler chỉ thực hiện một phương thức \textit{Handle} với logic mỏng.

Lớp Order đại diện cho đơn hàng, quản lý dữ liệu tài chính, danh sách món đã đặt và các mốc trạng thái trong vòng đời xử lý. Thiết kế của lớp thể hiện rõ các thuộc tính tài chính (Subtotal, DiscountAmount, DeliveryFee, TipAmount, TaxAmount, TotalAmount) cùng các phương thức chuyển trạng thái như Accept, Reject, MarkAsPreparing, MarkAsReadyForDelivery và MarkAsDelivered, đồng thời phát sinh các sự kiện miền tương ứng phục vụ đồng bộ trạng thái theo thời gian thực. Hình \ref{fig:class-order} mô tả cấu trúc lớp Order và các mối quan hệ chính.

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{Hinhve/class-Order.png}
    \caption{Biểu đồ lớp của Order (Aggregate root)}
    \label{fig:class-order}
\end{figure}

Lớp TeamCart mô hình hóa giỏ hàng nhóm, cho phép nhiều người cùng đặt món và phối hợp thanh toán. Các thuộc tính cốt lõi gồm thông tin thành viên, danh sách món, trạng thái giỏ và các cấu phần tài chính như TipAmount và QuoteVersion. Các phương thức như AddItem, LockForPayment, FinalizePricing và RecordSuccessfulOnlinePayment giúp đảm bảo tính nhất quán của luồng thanh toán nhóm. Hình \ref{fig:class-teamcart} trình bày thiết kế lớp TeamCart.

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{Hinhve/class-TeamCart.png}
    \caption{Biểu đồ lớp của TeamCart (Aggregate root)}
    \label{fig:class-teamcart}
\end{figure}

Lớp Restaurant quản lý hồ sơ nhà hàng, các thông tin định danh và trạng thái hoạt động như đã xác thực hay đang nhận đơn. Thiết kế này đảm bảo các ràng buộc nghiệp vụ khi thay đổi thông tin thương hiệu, địa điểm, khung giờ hoạt động và trạng thái xác thực. Lớp MenuItem quản lý món ăn của nhà hàng, hỗ trợ các thao tác cập nhật mô tả, giá, khả dụng và cấu hình nhóm tùy chọn. Hai lớp này lần lượt được minh họa tại Hình \ref{fig:class-restaurant} và Hình \ref{fig:class-menuitem}.

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{Hinhve/class-Restaurant.png}
    \caption{Biểu đồ lớp của Restaurant (Aggregate root)}
    \label{fig:class-restaurant}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{Hinhve/class-MenuItem.png}
    \caption{Biểu đồ lớp của MenuItem (Aggregate root)}
    \label{fig:class-menuitem}
\end{figure}

Để minh họa cách các lớp phối hợp trong các ca sử dụng quan trọng, ba luồng chính được lựa chọn gồm khởi tạo đơn hàng, chuyển TeamCart thành Order và cập nhật trạng thái đơn hàng. Luồng khởi tạo đơn hàng thể hiện kiểm tra nhà hàng, món ăn, tính phí và tạo thanh toán, sau đó sinh Order ở lớp miền. Luồng chuyển TeamCart thành Order nhấn mạnh vai trò của Domain Service trong việc ánh xạ dữ liệu và tính toán tài chính trước khi tạo Order và cập nhật TeamCart. Luồng cập nhật trạng thái đơn hàng thể hiện các chuyển trạng thái hợp lệ trong Order và phát sinh sự kiện miền để phục vụ cập nhật thời gian thực. Các luồng này được trình bày lần lượt tại Hình \ref{fig:flow-initiate-order}, Hình \ref{fig:flow-convert-teamcart} và Hình \ref{fig:flow-update-order-status}.

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth,height=0.95\textheight]{Hinhve/flow-InitiateOrder.png}
    \caption{Biểu đồ trình tự khởi tạo đơn hàng}
    \label{fig:flow-initiate-order}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth,height=0.95\textheight]{Hinhve/flow-ConvertTeamCart.png}
    \caption{Biểu đồ trình tự chuyển TeamCart thành Order}
    \label{fig:flow-convert-teamcart}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth,height=0.95\textheight,keepaspectratio]{Hinhve/flow-UpdateOrderStatus.png}
    \caption{Biểu đồ trình tự cập nhật trạng thái đơn hàng}
    \label{fig:flow-update-order-status}
\end{figure}

\subsection{Thiết kế cơ sở dữ liệu}
Phần này có độ dài từ hai đến bốn trang. Sinh viên thiết kế, vẽ và giải thích biểu đồ thực thể liên kết (E-R diagram). Từ đó, sinh viên thiết kế cơ sở dữ liệu tùy theo hệ quản trị cơ sở dữ liệu mà mình sử dụng (SQL, NoSQL, Firebase, v.v.)

\section{Xây dựng ứng dụng}
\subsection{Thư viện và công cụ sử dụng}
Sinh viên liệt kê các công cụ, ngôn ngữ lập trình, API, thư viện, IDE, công cụ kiểm thử, v.v. mà mình sử dụng để phát triển ứng dụng. Mỗi công cụ phải được chỉ rõ phiên bản sử dụng. SV nên kẻ bảng mô tả tương tự như Bảng \ref{table:my_label}. Nếu có nhiều nội dung trình bày, sinh viên cần xoay ngang bảng.

\begin{table}[H]
\centering{}
    \begin{tabular}{lll}
        \hline
        \textbf{Mục đích} & \textbf{Công cụ}       & \textbf{Địa chỉ URL}    \\ \hline
        IDE lập trình     & Eclipse Oxygen a64 bit & http://www.eclipse.org/ \\ \hline
        v.v.              & v.v.                   & v.v.                    \\ \hline
        \end{tabular}
    \caption{Danh sách thư viện và công cụ sử dụng}
    \label{table:my_label}
\end{table}

\subsection{Kết quả đạt được}
Sinh viên trước tiên mô tả kết quả đạt được của mình là gì, ví dụ như các sản phẩm được đóng gói là gì, bao gồm những thành phần nào, ý nghĩa, vai trò?

Sinh viên cần thống kê các thông tin về ứng dụng của mình như: số dòng code, số lớp, số gói, dung lượng toàn bộ mã nguồn, dung lượng của từng sản phẩm đóng gói, v.v. Tương tự như phần liệt kê về công cụ sử dụng, sinh viên cũng nên dùng bảng để mô tả phần thông tin thống kê này.

\subsection{Minh họa các chức năng chính}
Sinh viên lựa chọn và đưa ra màn hình cho các chức năng chính, quan trọng, và thú vị nhất. Mỗi giao diện cần phải có lời giải thích ngắn gọn. Khi giải thích, sinh viên có thể kết hợp với các chú thích ở trong hình ảnh giao diện.

\section{Kiểm thử}
Phần này có độ dài từ hai đến ba trang. Sinh viên thiết kế các trường hợp kiểm thử cho hai đến ba chức năng quan trọng nhất. Sinh viên cần chỉ rõ các kỹ thuật kiểm thử đã sử dụng. Chi tiết các trường hợp kiểm thử khác, nếu muốn trình bày, sinh viên đưa vào phần phụ lục.
Sinh viên sau cùng tổng kết về số lượng các trường hợp kiểm thử và kết quả kiểm thử. Sinh viên cần phân tích lý do nếu kết quả kiểm thử không đạt.

\section{Triển khai}
Sinh viên trình bày mô hình và/hoặc cách thức triển khai thử nghiệm/thực tế. Ứng dụng của sinh viên được triển khai trên server/thiết bị gì, cấu hình như thế nào. Kết quả triển khai thử nghiệm nếu có (số lượng người dùng, số lượng truy cập, thời gian phản hồi, phản hồi người dùng, khả năng chịu tải, các thống kê, v.v.)

\end{document}
