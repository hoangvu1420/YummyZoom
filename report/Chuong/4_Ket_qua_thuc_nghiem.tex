\documentclass[../DoAn.tex]{subfiles}
\begin{document}

\section{Thiết kế kiến trúc}
\subsection{Lựa chọn kiến trúc phần mềm}
\label{subsec:4.1.1}

Dựa trên các yêu cầu nghiệp vụ phức tạp của hệ thống YummyZoom, đặc biệt là tính năng đặt hàng nhóm (TeamCart) với yêu cầu về tính nhất quán dữ liệu cao và khả năng xử lý đồng thời, đồ án lựa chọn áp dụng kiến trúc \textbf{Clean Architecture} (Kiến trúc Sạch) kết hợp với tư duy thiết kế \textbf{Domain-Driven Design (DDD)}. Về mặt triển khai, hệ thống được xây dựng theo mô hình \textbf{Monolithic Modular} (Đơn khối module hóa).

\subsubsection{Mô hình kiến trúc tổng thể}
Thay vì lựa chọn kiến trúc Microservices ngay từ đầu - vốn đòi hỏi chi phí vận hành và quản lý hạ tầng lớn, hay kiến trúc Layered (3 lớp) truyền thống dễ gây ra sự phụ thuộc chặt chẽ vào cơ sở dữ liệu, nhóm phát triển quyết định sử dụng mô hình Monolithic Modular.

Mô hình này giúp cân bằng giữa tốc độ phát triển và khả năng mở rộng:
\begin{itemize}
    \item \textbf{Phát triển nhanh và nhất quán:} Toàn bộ mã nguồn nằm trong một Solution thống nhất, giúp việc gỡ lỗi (debug), kiểm thử và tái cấu trúc (refactor) trở nên dễ dàng hơn.
    \item \textbf{Ranh giới nghiệp vụ rõ ràng (Modular Boundaries):} Các module được tổ chức độc lập về mặt logic dựa trên các Bounded Contexts. Điều này tạo tiền đề vững chắc để tách thành các Microservices riêng biệt khi hệ thống cần mở rộng quy mô trong tương lai mà không làm phá vỡ cấu trúc hiện tại.
    \item \textbf{Tập trung vào nghiệp vụ cốt lõi:} Clean Architecture giúp cô lập logic nghiệp vụ (Domain) khỏi các yếu tố thay đổi thường xuyên như giao diện người dùng (UI) hay công nghệ lưu trữ (Database).
\end{itemize}

\subsubsection{Tổ chức các tầng kiến trúc (Layered Architecture)}
Hệ thống tuân thủ nghiêm ngặt quy tắc phụ thuộc (Dependency Rule) của Clean Architecture: "Mọi sự phụ thuộc của mã nguồn chỉ được hướng vào bên trong". Cấu trúc dự án được ánh xạ từ lý thuyết vào thực tế như sau:

\begin{enumerate}
    \item \textbf{Tầng Miền (Domain Layer) - \textit{Project: YummyZoom.Domain}}
    \newline Đây là lõi trung tâm của hệ thống, nơi chứa các quy tắc nghiệp vụ bất biến của doanh nghiệp. Tầng này hoàn toàn không phụ thuộc vào bất kỳ thư viện bên ngoài hay công nghệ cơ sở dữ liệu nào.
    \begin{itemize}
        \item \textbf{Thành phần:} Entities (Thực thể), Value Objects (Đối tượng giá trị), Aggregates (Hợp nhất), Domain Events.
        \item \textbf{Ví dụ thực tế:} Aggregate \texttt{TeamCart} đóng gói logic nghiệp vụ của giỏ hàng nhóm, đảm bảo các quy tắc như: một giỏ hàng chỉ có một chủ phòng (Host), và chỉ Host mới có quyền chốt đơn hoặc khóa giỏ hàng.
    \end{itemize}

    \item \textbf{Tầng Ứng dụng (Application Layer) - \textit{Project: YummyZoom.Application}}
    \newline Đóng vai trò lớp vỏ bao quanh Domain, điều phối các yêu cầu từ người dùng và chuyển đổi chúng thành các thao tác nghiệp vụ.
    \begin{itemize}
        \item \textbf{Thành phần:} Use Cases (được triển khai dưới dạng Command/Query Handlers), Validators (Kiểm tra dữ liệu), Interfaces cho Infrastructure.
        \item \textbf{Ví dụ thực tế:} AddItemToTeamCartCommand là một Use Case nhận yêu cầu thêm món, kích hoạt phương thức AddItem trong Domain Entity, và sau đó lưu thay đổi thông qua ITeamCartRepository.
    \end{itemize}

    \item \textbf{Tầng Hạ tầng (Infrastructure Layer) - \textit{Project: YummyZoom.Infrastructure}}
    \newline Nơi chưa các thực thi của các interfaces kỹ thuật được định nghĩa ở tầng Application. Đây là nơi các công nghệ cụ thể được "cắm" vào hệ thống.
    \begin{itemize}
        \item \textbf{Thành phần:} DbContext (Entity Framework Core), Repositories Implementation, Services giao tiếp bên ngoài (EmailService, CloudinaryService, StripeService, FCMService).
        \item \textbf{Chức năng:} Truy xuất dữ liệu từ SQL Server/PostgreSQL, tương tác với hệ thống file, gửi email xác nhận, xử lý thanh toán qua Stripe, gửi thông báo đẩy với FCM.
    \end{itemize}

    \item \textbf{Tầng Giao diện/Trình bày (Web/Presentation Layer) - \textit{Project: YummyZoom.Web}}
    \newline Lớp vỏ ngoài cùng, chịu trách nhiệm giao tiếp với Client (Mobile App, Web Admin).
    \begin{itemize}
        \item \textbf{Thành phần:} Minimal APIs, SignalR Hubs, Middlewares.
        \item \textbf{Nhiệm vụ:} Nhận HTTP Request, xác thực token, gọi xuống Application Layer để xử lý và trả về HTTP Response chuẩn (JSON).
    \end{itemize}
\end{enumerate}

\subsubsection{Thiết kế chiến lược (Strategic Design)}
Áp dụng chiến lược của DDD, hệ thống được chia nhỏ thành các \textbf{Bounded Contexts} (Ngữ cảnh giới hạn), mỗi context giải quyết một vấn đề nghiệp vụ cụ thể và có Ubiquitous Language (Ngôn ngữ chung) riêng:
\begin{itemize}
    \item \textbf{Identity Context:} Quản lý người dùng, phân quyền và xác thực (Authentication/Authorization).
    \item \textbf{Catalog Context:} Quản lý thực đơn, danh mục, thông tin nhà hàng, món ăn và các tùy chọn (Toppings).
    \item \textbf{TeamCart Context:} Ngữ cảnh quan trọng và phức tạp nhất, xử lý logic chia sẻ giỏ hàng, đồng bộ trạng thái thời gian thực và phân chia hóa đơn.
    \item \textbf{Ordering Context:} Xử lý quy trình đặt hàng, thanh toán và vòng đời của đơn hàng sau khi được chốt.
\end{itemize}

\subsubsection{Các mẫu kỹ thuật chủ đạo (Tactical Patterns)}
Để tối ưu hóa hiệu năng và khả năng bảo trì, hệ thống áp dụng các mẫu thiết kế kỹ thuật nâng cao:

\paragraph{CQRS (Command Query Responsibility Segregation):}
Hệ thống tách biệt rõ ràng luồng Đọc (Query) và Ghi (Command) dữ liệu:
\begin{itemize}
    \item \textbf{Phần Ghi (Write Side):} Sử dụng \textbf{Entity Framework Core} kết hợp với Domain Model để đảm bảo tính toàn vẹn và nhất quán dữ liệu (Data Consistency) khi thực hiện các thay đổi nghiệp vụ.
    \item \textbf{Phần Đọc (Read Side):} Sử dụng \textbf{Dapper} với SQL để truy vấn dữ liệu trực tiếp và trả về các DTO phẳng. Đồng thời, hệ thống kết hợp sử dụng các \textbf{Read Models} được cập nhật song song với các bảng ghi, giúp tránh việc thực hiện các phép JOIN bảng quá mức. Cách tiếp cận này đảm bảo khả năng phục vụ hiệu quả các yêu cầu dữ liệu phức tạp từ ứng dụng người dùng với tốc độ phản hồi tối ưu.
\end{itemize}

\paragraph{Domain Events \& Outbox Pattern:}
Giải quyết bài toán về tính nhất quán cuối cùng (Eventual Consistency) và xử lý bất đồng bộ:
\begin{itemize}
    \item \textbf{Cơ chế:} Khi một nghiệp vụ quan trọng hoàn tất (ví dụ: \texttt{OrderCreated}), hệ thống không gọi trực tiếp các dịch vụ bên thứ ba (như gửi email) mà sinh ra một \texttt{Domain Event}. Event này được lưu vào bảng \texttt{OutboxMessages} trong cùng một transaction database với dữ liệu chính.
    \item \textbf{Tác dụng:} Một tiến trình nền (Background Worker) sẽ đọc bảng Outbox và thực hiện các tác vụ phụ sau đó. Điều này đảm bảo rằng giao dịch chính luôn nhanh và an toàn; nếu việc gửi email thất bại, nó sẽ được thử lại (Retry) mà không làm mất đơn hàng.
\end{itemize}

\subsubsection{Kết luận}
Việc lựa chọn kiến trúc Clean Architecture kết hợp DDD và CQRS mang lại nền tảng vững chắc cho hệ thống YummyZoom. Kiến trúc này không chỉ giải quyết tốt các bài toán nghiệp vụ phức tạp hiện tại về đặt hàng nhóm mà còn đảm bảo các tiêu chí phi chức năng quan trọng: dễ dàng kiểm thử (Testability), dễ bảo trì (Maintainability) và sẵn sàng mở rộng (Scalability) trong tương lai.

\subsection{Thiết kế tổng quan}
Biểu đồ gói tổng quan của hệ thống YummyZoom thể hiện sự phân tầng rõ ràng và các ràng buộc phụ thuộc tuân thủ quy tắc Clean Architecture. 
\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{Hinhve/package_overview.png}
    \caption{Biểu đồ phụ thuộc gói tổng quan YummyZoom (Backend)}
    \label{fig:FigPackageOverview}
\end{figure}

\subsection{Thiết kế chi tiết gói}
Mục tiêu của phần này là minh họa chi tiết cách tổ chức mã nguồn và hiện thực hóa kiến trúc Clean Architecture thông qua các biểu đồ gói (Package Diagrams). Tôi đã lựa chọn 2 luồng nghiệp vụ tiêu biểu đại diện cho hai phân hệ quan trọng nhất: Restaurant (Nhà hàng) và Order (Đơn hàng) để phân tích.

Các biểu đồ được xây dựng dựa trên các quy tắc sau nhằm đảm bảo tính trực quan và tránh sự quá tải thông tin do số lượng lớp lớn của hệ thống:
\begin{itemize}
    \item \textbf{Phạm vi:} Mỗi biểu đồ tập trung vào một luồng nghiệp vụ cụ thể (bao gồm 1 Command và 1 Query), không bao gồm toàn bộ các lớp trong mã nguồn.
    \item \textbf{Cấu trúc:} Các thành phần được vẽ và sắp xếp dọc theo 4 tầng của Clean Architecture (Web, Application, Domain, Infrastructure).
    \item \textbf{Chi tiết:} Chỉ thể hiện tên lớp và các mối quan hệ chính, lược bỏ các phương thức và thuộc tính chi tiết.
\end{itemize}

\subsubsection{Biểu đồ 1: Restaurant (Create Restaurant + Search Restaurants)}
Biểu đồ này minh họa luồng xử lý cho hai chức năng: Phê duyệt đăng ký nhà hàng (Create) và Tìm kiếm nhà hàng (Search).

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth,height=0.95\textheight,keepaspectratio]{Hinhve/package_restaurant_create_search.png}
    \caption{Biểu đồ gói chi tiết phân hệ Restaurant (Create \& Search)}
    \label{fig:PkgRestaurant}
\end{figure}

\noindent \textbf{Mô tả luồng logic:}
Biểu đồ thể hiện cách các tầng phối hợp để xử lý yêu cầu:
\begin{itemize}
    \item \textbf{Luồng Ghi (Command):} Bắt đầu từ yêu cầu POST đến Endpoints/RestaurantRegistrations để phê duyệt đăng ký nhà hàng, yêu cầu phê duyệt được chuyển đến ApproveRestaurantRegistrationCommandHandler (Application). Handler này tương tác với Domain (RestaurantAggregate, RestaurantRegistration) để đảm bảo quy tắc nghiệp vụ, rồi một đối tượng Restaurant được tạo và lưu trữ qua RestaurantRepository (Infrastructure) xuống database. Khi thành công, sự kiện RestaurantCreated được phát ra và được xử lý bởi RestaurantCreatedSearchHandler (Application) để cập nhật bảng SearchIndex trong database để phục phụ cho thao tác tìm kiếm sau này.
    \item \textbf{Luồng Đọc (Query):} Khi yêu cầu GET đến Restaurants để tìm kiếm nhà hàng theo các tiêu chí, SearchRestaurantsQueryHandler (Application) thực hiện truy vấn tối ưu bằng SQL vào bảng SearchIndex là một Read Model tối ưu hóa để phục vụ tìm kiếm. Dữ liệu phục vụ tìm kiếm được cập nhật bất đồng bộ bởi SearchIndexMaintainer (Infrastructure) ngay khi nhận được sự kiện RestaurantCreated, minh họa cho mô hình CQRS tách biệt Ghi và Đọc.
\end{itemize}

\subsubsection{Biểu đồ 2: Order (Initiate Order + Get Order Status)}
Biểu đồ này mô tả quy trình khởi tạo đơn hàng mới và truy vấn trạng thái đơn hàng, đóng vai trò cốt lõi trong giao dịch thương mại của hệ thống.

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth,height=0.95\textheight,keepaspectratio]{Hinhve/package_order_initiate_status.png}
    \caption{Biểu đồ gói chi tiết phân hệ Order (Initiate \& Status)}
    \label{fig:PkgOrder}
\end{figure}

\noindent \textbf{Mô tả luồng logic:}
Biểu đồ minh họa sự phối hợp chặt chẽ giữa các thành phần để xử lý đơn hàng:
\begin{itemize}
    \item \textbf{Luồng Ghi (Command):} Yêu cầu đặt hàng từ người dùng (Web Endpoints) được đóng gói thành InitiateOrderCommand. InitiateOrderCommandHandler đóng vai trò điều phối chính: nó sử dụng OrderFinancialService (một Domain Service) để tính toán chi phí, xác thực qua IPaymentGatewayService, và tương tác với các repositories (IOrderRepository, ICouponRepository) để lưu trữ Aggregate Order. Thành công kích hoạt sự kiện OrderPlaced, dẫn đến việc OrderPlacedEventHandler gọi các dịch vụ thông báo (IOrderRealtimeNotifier, IOrderPushNotifier).
    \item \textbf{Luồng Đọc (Query):} GetOrderStatusQueryHandler tiếp nhận yêu cầu truy vấn và trả về thông tin trạng thái đơn hàng, đảm bảo tính cập nhật cho phía người dùng.
\end{itemize}

\section{Thiết kế chi tiết}
\subsection{Thiết kế giao diện}
Phần này có độ dài từ hai đến ba trang. Sinh viên đặc tả thông tin về màn hình mà ứng dụng của mình hướng tới, bao gồm độ phân giải màn hình, kích thước màn hình, số lượng màu sắc hỗ trợ, v.v. Tiếp đến, sinh viên đưa ra các thống nhất/chuẩn hóa của mình khi thiết kế giao diện như thiết kế nút, điều khiển, vị trí hiển thị thông điệp phản hồi, phối màu, v.v. Sau cùng sinh viên đưa ra một số hình ảnh minh họa thiết kế giao diện cho các chức năng quan trọng nhất. Lưu ý, sinh viên không nhầm lẫn giao diện thiết kế với giao diện của sản phẩm sau cùng.
\subsection{Thiết kế lớp}
Phần này có độ dài từ ba đến bốn trang. Sinh viên trình bày thiết kế chi tiết các thuộc tính và phương thức cho một số lớp chủ đạo/quan trọng nhất của ứng dụng (từ 2-4 lớp). Thiết kế chi tiết cho các lớp khác, nếu muốn trình bày, sinh viên đưa vào phần phụ lục.

Để minh họa thiết kế lớp, sinh viên thiết kế luồng truyền thông điệp giữa các đối tượng tham gia cho 2 đến 3 use case quan trọng nào đó bằng biểu đồ trình tự (hoặc biểu đồ giao tiếp).
\subsection{Thiết kế cơ sở dữ liệu}
Phần này có độ dài từ hai đến bốn trang. Sinh viên thiết kế, vẽ và giải thích biểu đồ thực thể liên kết (E-R diagram). Từ đó, sinh viên thiết kế cơ sở dữ liệu tùy theo hệ quản trị cơ sở dữ liệu mà mình sử dụng (SQL, NoSQL, Firebase, v.v.)

\section{Xây dựng ứng dụng}
\subsection{Thư viện và công cụ sử dụng}
Sinh viên liệt kê các công cụ, ngôn ngữ lập trình, API, thư viện, IDE, công cụ kiểm thử, v.v. mà mình sử dụng để phát triển ứng dụng. Mỗi công cụ phải được chỉ rõ phiên bản sử dụng. SV nên kẻ bảng mô tả tương tự như Bảng \ref{table:my_label}. Nếu có nhiều nội dung trình bày, sinh viên cần xoay ngang bảng.

\begin{table}[H]
\centering{}
    \begin{tabular}{lll}
        \hline
        \textbf{Mục đích} & \textbf{Công cụ}       & \textbf{Địa chỉ URL}    \\ \hline
        IDE lập trình     & Eclipse Oxygen a64 bit & http://www.eclipse.org/ \\ \hline
        v.v.              & v.v.                   & v.v.                    \\ \hline
        \end{tabular}
    \caption{Danh sách thư viện và công cụ sử dụng}
    \label{table:my_label}
\end{table}

\subsection{Kết quả đạt được}
Sinh viên trước tiên mô tả kết quả đạt được của mình là gì, ví dụ như các sản phẩm được đóng gói là gì, bao gồm những thành phần nào, ý nghĩa, vai trò?

Sinh viên cần thống kê các thông tin về ứng dụng của mình như: số dòng code, số lớp, số gói, dung lượng toàn bộ mã nguồn, dung lượng của từng sản phẩm đóng gói, v.v. Tương tự như phần liệt kê về công cụ sử dụng, sinh viên cũng nên dùng bảng để mô tả phần thông tin thống kê này.

\subsection{Minh họa các chức năng chính}
Sinh viên lựa chọn và đưa ra màn hình cho các chức năng chính, quan trọng, và thú vị nhất. Mỗi giao diện cần phải có lời giải thích ngắn gọn. Khi giải thích, sinh viên có thể kết hợp với các chú thích ở trong hình ảnh giao diện.

\section{Kiểm thử}
Phần này có độ dài từ hai đến ba trang. Sinh viên thiết kế các trường hợp kiểm thử cho hai đến ba chức năng quan trọng nhất. Sinh viên cần chỉ rõ các kỹ thuật kiểm thử đã sử dụng. Chi tiết các trường hợp kiểm thử khác, nếu muốn trình bày, sinh viên đưa vào phần phụ lục.
Sinh viên sau cùng tổng kết về số lượng các trường hợp kiểm thử và kết quả kiểm thử. Sinh viên cần phân tích lý do nếu kết quả kiểm thử không đạt.

\section{Triển khai}
Sinh viên trình bày mô hình và/hoặc cách thức triển khai thử nghiệm/thực tế. Ứng dụng của sinh viên được triển khai trên server/thiết bị gì, cấu hình như thế nào. Kết quả triển khai thử nghiệm nếu có (số lượng người dùng, số lượng truy cập, thời gian phản hồi, phản hồi người dùng, khả năng chịu tải, các thống kê, v.v.)

\end{document}
