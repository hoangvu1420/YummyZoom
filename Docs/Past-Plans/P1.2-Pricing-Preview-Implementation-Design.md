# P1.2 Pricing Preview Implementation Design

**Date:** 2025-01-27  
**Author:** Backend Team  
**Status:** Design Phase  

## Executive Summary

This document presents the comprehensive design for implementing the P1.2 Pricing Preview feature as proposed by the frontend team. The implementation will provide authoritative pricing calculations before order submission, eliminating client-side pricing drift and improving checkout UX.

## Problem Statement

**Current Issue:** The frontend mirrors pricing logic (tax 8%, delivery fee $2.99) which can drift due to:
- Restaurant-specific promotions
- Dynamic pricing changes
- Regional tax variations
- Fee structure updates

**Impact:** Poor user experience with pricing discrepancies between preview and final order totals.

## Proposed Solution

Implement a dedicated pricing preview endpoint that provides authoritative, server-side pricing calculations using the same business logic as the order creation process.

## Architecture Analysis

### Current System Capabilities

The codebase already provides excellent foundations for this feature:

1. **Domain Financial Service**: `OrderFinancialService` contains canonical pricing logic
2. **Menu Item Loading**: Established patterns in `InitiateOrderCommandHandler` for loading menu items and customizations
3. **Coupon Validation**: Comprehensive coupon validation in `OrderFinancialService.ValidateAndCalculateDiscount`
4. **CQRS Pattern**: Clean separation between commands and queries
5. **Result Pattern**: Consistent error handling throughout the application

### Design Principles

1. **Reuse Existing Logic**: Leverage `OrderFinancialService` and existing item loading patterns
2. **Stateless Operations**: No side effects or state changes during preview
3. **Performance Optimization**: Efficient data loading with minimal database queries
4. **Error Transparency**: Clear messaging about pricing changes or item unavailability
5. **MVP Scope**: Focus on core functionality with room for future enhancements

## Implementation Design

### 1. Application Layer Components

#### 1.1 Query Definition

```csharp
// src/Application/Pricing/Queries/GetPricingPreview/GetPricingPreviewQuery.cs
[Authorize]
public record GetPricingPreviewQuery(
    Guid RestaurantId,
    List<PricingPreviewItemDto> Items,
    string? CouponCode = null,
    decimal? TipAmount = null
) : IRequest<Result<GetPricingPreviewResponse>>, ICacheableQuery<GetPricingPreviewResponse>;

public record PricingPreviewItemDto(
    Guid MenuItemId,
    int Quantity,
    List<PricingPreviewCustomizationDto>? Customizations = null
);

public record PricingPreviewCustomizationDto(
    Guid CustomizationGroupId,
    List<Guid> ChoiceIds
);
```

#### 1.2 Response Definition

```csharp
public record GetPricingPreviewResponse(
    Money Subtotal,
    Money? DiscountAmount,
    Money DeliveryFee,
    Money TipAmount,
    Money TaxAmount,
    Money TotalAmount,
    string Currency,
    List<PricingPreviewNoteDto> Notes,
    DateTime CalculatedAt
);

public record PricingPreviewNoteDto(
    string Type, // "info", "warning", "error"
    string Code,
    string Message,
    Dictionary<string, object>? Metadata = null
);
```

#### 1.3 Query Handler

```csharp
// src/Application/Pricing/Queries/GetPricingPreview/GetPricingPreviewQueryHandler.cs
public class GetPricingPreviewQueryHandler : IRequestHandler<GetPricingPreviewQuery, Result<GetPricingPreviewResponse>>
{
    private readonly IMenuItemRepository _menuItemRepository;
    private readonly ICustomizationGroupRepository _customizationGroupRepository;
    private readonly ICouponRepository _couponRepository;
    private readonly IRestaurantRepository _restaurantRepository;
    private readonly OrderFinancialService _orderFinancialService;
    private readonly ILogger<GetPricingPreviewQueryHandler> _logger;

    public async Task<Result<GetPricingPreviewResponse>> Handle(
        GetPricingPreviewQuery request, 
        CancellationToken cancellationToken)
    {
        // 1. Validate restaurant exists and is active
        var restaurant = await _restaurantRepository.GetByIdAsync(
            RestaurantId.Create(request.RestaurantId), cancellationToken);
        
        if (restaurant is null || !restaurant.IsActive)
        {
            return Result.Failure<GetPricingPreviewResponse>(
                PricingPreviewErrors.RestaurantNotFoundOrInactive);
        }

        // 2. Load and validate menu items
        var menuItemIds = request.Items.Select(i => MenuItemId.Create(i.MenuItemId)).ToList();
        var menuItems = await _menuItemRepository.GetByIdsAsync(menuItemIds, cancellationToken);
        
        var notes = new List<PricingPreviewNoteDto>();
        var validOrderItems = new List<OrderItem>();

        // 3. Build temporary OrderItems for pricing calculation
        foreach (var requestItem in request.Items)
        {
            var menuItemId = MenuItemId.Create(requestItem.MenuItemId);
            var menuItem = menuItems.FirstOrDefault(m => m.Id == menuItemId);
            
            if (menuItem is null)
            {
                notes.Add(new PricingPreviewNoteDto("error", "MENU_ITEM_NOT_FOUND", 
                    $"Menu item {requestItem.MenuItemId} not found"));
                continue;
            }

            if (!menuItem.IsAvailable)
            {
                notes.Add(new PricingPreviewNoteDto("warning", "MENU_ITEM_UNAVAILABLE", 
                    $"Menu item '{menuItem.Name}' is currently unavailable"));
                continue;
            }

            // Build customizations using existing patterns from InitiateOrderCommandHandler
            var customizations = await BuildOrderItemCustomizations(
                menuItem, requestItem.Customizations, request.RestaurantId, cancellationToken);
            
            if (customizations.IsFailure)
            {
                notes.Add(new PricingPreviewNoteDto("error", "CUSTOMIZATION_INVALID", 
                    customizations.Error.Message));
                continue;
            }

            // Create temporary OrderItem for pricing calculation
            var orderItem = OrderItem.CreateTemporaryForPricing(
                menuItem, requestItem.Quantity, customizations.Value);
            
            validOrderItems.Add(orderItem);
        }

        if (!validOrderItems.Any())
        {
            return Result.Failure<GetPricingPreviewResponse>(
                PricingPreviewErrors.NoValidItems);
        }

        // 4. Calculate subtotal
        var subtotal = _orderFinancialService.CalculateSubtotal(validOrderItems);
        
        // 5. Apply coupon if provided
        Money? discountAmount = null;
        if (!string.IsNullOrWhiteSpace(request.CouponCode))
        {
            var coupon = await _couponRepository.GetByCodeAsync(
                request.CouponCode.Trim().ToUpperInvariant(), 
                restaurant.Id, 
                cancellationToken);
            
            if (coupon is not null)
            {
                var discountResult = _orderFinancialService.ValidateAndCalculateDiscount(
                    coupon, validOrderItems, subtotal);
                
                if (discountResult.IsSuccess)
                {
                    discountAmount = discountResult.Value;
                }
                else
                {
                    notes.Add(new PricingPreviewNoteDto("warning", "COUPON_INVALID", 
                        $"Coupon '{request.CouponCode}': {discountResult.Error.Message}"));
                }
            }
            else
            {
                notes.Add(new PricingPreviewNoteDto("warning", "COUPON_NOT_FOUND", 
                    $"Coupon '{request.CouponCode}' not found"));
            }
        }

        // 6. Get pricing configuration using centralized static service (MVP approach)
        var pricingConfig = StaticPricingService.GetPricingConfiguration(restaurant.Id);
        
        var tipAmount = new Money(request.TipAmount ?? 0m, subtotal.Currency);
        var deliveryFee = pricingConfig.DeliveryFee;
        
        // Calculate tax based on policy using centralized service
        var taxBase = StaticPricingService.CalculateTaxBase(subtotal, deliveryFee, tipAmount, pricingConfig.TaxBasePolicy);
        var taxAmount = new Money(taxBase.Amount * pricingConfig.TaxRate, subtotal.Currency);

        // 7. Calculate final total using enhanced financial service with static pricing
        var finalTotal = _orderFinancialService.CalculateFinalTotalWithStaticPricing(
            restaurant.Id,
            subtotal, 
            discountAmount ?? Money.Zero(subtotal.Currency), 
            tipAmount);

        return Result.Success(new GetPricingPreviewResponse(
            subtotal,
            discountAmount,
            deliveryFee,
            tipAmount,
            taxAmount,
            finalTotal,
            subtotal.Currency,
            notes,
            DateTime.UtcNow
        ));
    }

    private async Task<Result<List<OrderItemCustomization>>> BuildOrderItemCustomizations(
        MenuItem menuItem,
        List<PricingPreviewCustomizationDto>? requestCustomizations,
        Guid restaurantId,
        CancellationToken cancellationToken)
    {
        // Reuse logic from InitiateOrderCommandHandler for consistency
        // Implementation details omitted for brevity
        // This method would follow the same validation patterns as the existing order creation flow
    }

}
```

#### 1.4 Caching Strategy

```csharp
// Implement ICacheableQuery for performance optimization
public CacheKey CacheKey => CacheKey.Create("pricing:preview:v1", 
    RestaurantId.ToString("N"), 
    HashItemsAndCustomizations(Items));

public CachePolicy CachePolicy => CachePolicy.WithTtl(
    TimeSpan.FromMinutes(2), 
    $"restaurant:{RestaurantId}:menu");
```

#### 1.5 Validation

```csharp
// src/Application/Pricing/Queries/GetPricingPreview/GetPricingPreviewQueryValidator.cs
public class GetPricingPreviewQueryValidator : AbstractValidator<GetPricingPreviewQuery>
{
    public GetPricingPreviewQueryValidator()
    {
        RuleFor(x => x.RestaurantId).NotEmpty();
        RuleFor(x => x.Items).NotEmpty().WithMessage("At least one item is required");
        RuleForEach(x => x.Items).SetValidator(new PricingPreviewItemDtoValidator());
        RuleFor(x => x.TipAmount).GreaterThanOrEqualTo(0).When(x => x.TipAmount.HasValue);
        RuleFor(x => x.CouponCode).MaximumLength(50).When(x => !string.IsNullOrEmpty(x.CouponCode));
    }
}

public class PricingPreviewItemDtoValidator : AbstractValidator<PricingPreviewItemDto>
{
    public PricingPreviewItemDtoValidator()
    {
        RuleFor(x => x.MenuItemId).NotEmpty();
        RuleFor(x => x.Quantity).GreaterThan(0).LessThanOrEqualTo(99);
        RuleForEach(x => x.Customizations).SetValidator(new PricingPreviewCustomizationDtoValidator());
    }
}
```

### 2. Web Layer Implementation

#### 2.1 Endpoint Definition

```csharp
// src/Web/Endpoints/Pricing.cs
public class PricingEndpoints : IEndpointGroup
{
    public void Map(IEndpointRouteBuilder app)
    {
        var group = app.MapGroup("/api/v1/pricing")
            .WithTags("Pricing")
            .WithOpenApi();

        group.MapPost("/preview", GetPricingPreview)
            .WithName("GetPricingPreview")
            .WithSummary("Get authoritative pricing preview for order items")
            .WithDescription("Calculates pricing including taxes, fees, and discounts without creating an order")
            .Produces<GetPricingPreviewResponse>(StatusCodes.Status200OK)
            .ProducesProblem(StatusCodes.Status400BadRequest)
            .ProducesProblem(StatusCodes.Status404NotFound)
            .RequireAuthorization();
    }

    private static async Task<Results<Ok<GetPricingPreviewResponse>, BadRequest<ProblemDetails>, NotFound<ProblemDetails>>> 
        GetPricingPreview(
            GetPricingPreviewQuery request,
            ISender sender,
            CancellationToken cancellationToken)
    {
        var result = await sender.Send(request, cancellationToken);

        return result.Match(
            success => TypedResults.Ok(success),
            failure => failure.Code switch
            {
                "PricingPreview.RestaurantNotFound" => TypedResults.NotFound(
                    Results.Extensions.CreateProblemDetails(failure)),
                "PricingPreview.NoValidItems" => TypedResults.BadRequest(
                    Results.Extensions.CreateProblemDetails(failure)),
                _ => TypedResults.BadRequest(
                    Results.Extensions.CreateProblemDetails(failure))
            });
    }
}
```

### 3. Domain Layer Extensions

#### 3.1 Error Definitions

```csharp
// src/Domain/PricingAggregate/Errors/PricingPreviewErrors.cs
public static class PricingPreviewErrors
{
    public static readonly Error RestaurantNotFoundOrInactive = Error.NotFound(
        "PricingPreview.RestaurantNotFound",
        "Restaurant not found or inactive");

    public static readonly Error NoValidItems = Error.Validation(
        "PricingPreview.NoValidItems",
        "No valid items found for pricing calculation");

    public static readonly Error MenuItemNotFound = Error.NotFound(
        "PricingPreview.MenuItemNotFound",
        "Menu item not found");

    public static readonly Error MenuItemUnavailable = Error.Validation(
        "PricingPreview.MenuItemUnavailable",
        "Menu item is currently unavailable");
}
```

#### 3.2 OrderItem Factory Method

```csharp
// Extension to OrderItem for temporary pricing calculations
public static OrderItem CreateTemporaryForPricing(
    MenuItem menuItem,
    int quantity,
    List<OrderItemCustomization> customizations)
{
    // Create temporary OrderItem for pricing calculations without persistence
    // Implementation would mirror existing OrderItem creation logic
}
```

### 4. Performance Considerations

#### 4.1 Database Query Optimization

1. **Batch Loading**: Load all menu items and customization groups in single queries
2. **Selective Fields**: Only load necessary fields for pricing calculations
3. **Connection Reuse**: Use existing repository patterns for connection management

#### 4.2 Caching Strategy

1. **Short TTL**: 2-minute cache to balance performance and freshness
2. **Restaurant Scoped**: Cache keys include restaurant ID for invalidation
3. **Content Hashing**: Include item/customization hash in cache key

#### 4.3 Response Optimization

1. **Minimal Payload**: Only include essential pricing information
2. **Compressed Responses**: Leverage existing compression middleware
3. **Conditional Requests**: Support ETag headers for unchanged responses

### 5. Testing Strategy

#### 5.1 Unit Tests

```csharp
// tests/Application.UnitTests/Pricing/Queries/GetPricingPreviewQueryHandlerTests.cs
public class GetPricingPreviewQueryHandlerTests
{
    [Fact]
    public async Task Handle_WithValidItems_ReturnsCorrectPricing()
    {
        // Test happy path with various item combinations
    }

    [Fact]
    public async Task Handle_WithInvalidCoupon_ReturnsWarningNote()
    {
        // Test coupon validation scenarios
    }

    [Fact]
    public async Task Handle_WithUnavailableItem_ReturnsWarningNote()
    {
        // Test unavailable item handling
    }

    [Fact]
    public async Task Handle_WithNoValidItems_ReturnsError()
    {
        // Test error scenarios
    }
}
```

#### 5.2 Integration Tests

```csharp
// tests/Application.FunctionalTests/Pricing/GetPricingPreviewTests.cs
public class GetPricingPreviewTests : BaseIntegrationTest
{
    [Fact]
    public async Task GetPricingPreview_ReturnsCorrectCalculations()
    {
        // End-to-end test with real database
    }

    [Fact]
    public async Task GetPricingPreview_WithCoupon_AppliesCorrectDiscount()
    {
        // Test coupon application scenarios
    }
}
```

### 6. API Documentation

#### 6.1 Request Example

```json
POST /api/v1/pricing/preview
{
  "restaurantId": "f47ac10b-58cc-4372-a567-0e02b2c3d479",
  "items": [
    {
      "menuItemId": "550e8400-e29b-41d4-a716-446655440000",
      "quantity": 2,
      "customizations": [
        {
          "customizationGroupId": "550e8400-e29b-41d4-a716-446655440001",
          "choiceIds": ["550e8400-e29b-41d4-a716-446655440002"]
        }
      ]
    }
  ],
  "couponCode": "SAVE10",
  "tipAmount": 5.00
}
```

#### 6.2 Response Example

```json
{
  "subtotal": {
    "amount": 25.98,
    "currency": "USD"
  },
  "discountAmount": {
    "amount": 2.60,
    "currency": "USD"
  },
  "deliveryFee": {
    "amount": 2.99,
    "currency": "USD"
  },
  "tipAmount": {
    "amount": 5.00,
    "currency": "USD"
  },
  "taxAmount": {
    "amount": 2.07,
    "currency": "USD"
  },
  "totalAmount": {
    "amount": 33.44,
    "currency": "USD"
  },
  "currency": "USD",
  "notes": [
    {
      "type": "info",
      "code": "COUPON_APPLIED",
      "message": "Coupon 'SAVE10' applied successfully"
    }
  ],
  "calculatedAt": "2025-01-27T10:30:00Z"
}
```

### 7. Implementation Timeline

#### Phase 1: Core Implementation (3-4 days)
- [ ] Create application layer components (Query, Handler, Validator)
- [ ] Implement domain error definitions
- [ ] Add OrderItem factory method for temporary pricing
- [ ] Create web endpoint with basic functionality
- [ ] Integrate with StaticPricingService for consistent pricing

#### Phase 2: Testing & Validation (2-3 days)
- [ ] Write comprehensive unit tests
- [ ] Implement integration tests
- [ ] Add caching implementation
- [ ] Performance testing and optimization
- [ ] Validate pricing consistency with order creation

#### Phase 3: Documentation & Deployment (1-2 days)
- [ ] Update API documentation
- [ ] Create Postman collection
- [ ] Deploy to staging environment
- [ ] Frontend integration testing

**Total Estimated Effort:** 6-9 development days (includes MVP pricing integration)

### 8. Integration with MVP Centralized Pricing Constants

The P1.2 Pricing Preview implementation integrates with the MVP centralized static pricing service to ensure consistency across the entire system:

#### 8.1 Benefits of Integration
- **Consistency**: Same pricing logic used in preview and order creation
- **Centralized Constants**: All pricing values managed in one place
- **Maintainability**: Single source of truth for all pricing constants
- **Simplicity**: No database complexity, easy to implement and test

#### 8.2 Implementation Details
- Uses `StaticPricingService` to retrieve centralized pricing constants
- Supports configurable delivery fees, tax rates, and tax base policies through static values
- Provides consistent pricing across all handlers and services
- Enables future enhancements by replacing static service with database-backed solution

#### 8.3 MVP Pricing Constants Integration
The P1.2 implementation leverages the MVP centralized pricing constants approach:

```csharp
// Example integration in GetPricingPreviewQueryHandler
var pricingConfig = StaticPricingService.GetPricingConfiguration(restaurant.Id);
var deliveryFee = pricingConfig.DeliveryFee; // Uses centralized 2.99m constant
var taxRate = pricingConfig.TaxRate; // Uses centralized 0.08m constant
var taxBasePolicy = pricingConfig.TaxBasePolicy; // Uses centralized policy
```

This ensures that:
- **Preview calculations** use the same constants as **order creation**
- **TeamCart calculations** use the same constants as **individual orders**
- **All pricing logic** is consistent across the entire system
- **Future changes** to pricing constants only need to be made in one place

### 9. Future Enhancements

#### 9.1 Advanced Configuration Management
- Regional pricing variations based on delivery address
- Dynamic fee calculation based on distance/order value
- Time-based pricing (peak hours, holidays)
- A/B testing support for pricing experiments

#### 9.2 Advanced Features
- Support for promotional pricing
- Real-time inventory checking
- Delivery time estimation
- Multi-currency support

#### 9.3 Performance Optimizations
- Redis-based caching for high-traffic scenarios
- GraphQL endpoint for flexible data fetching
- CDN integration for static pricing data

### 10. Risk Mitigation

#### 10.1 Technical Risks
- **Performance Impact**: Mitigated by caching and optimized queries
- **Data Consistency**: Ensured by reusing existing business logic
- **Error Handling**: Comprehensive error scenarios covered

#### 10.2 Business Risks
- **Pricing Accuracy**: Same logic as order creation ensures consistency
- **User Experience**: Clear notes about pricing changes or item issues
- **Scalability**: Designed for high-volume usage with caching

### 11. Success Metrics

#### 11.1 Technical Metrics
- Response time < 200ms for typical requests
- Cache hit ratio > 80%
- Error rate < 0.1%

#### 11.2 Business Metrics
- Reduction in pricing discrepancy reports
- Improved checkout conversion rates
- Decreased support tickets related to pricing

## Conclusion

The P1.2 Pricing Preview implementation leverages existing architectural patterns and business logic to provide a robust, performant solution. The design maintains consistency with the current codebase while delivering the requested functionality with room for future enhancements.

The implementation follows Clean Architecture principles, maintains separation of concerns, and provides comprehensive error handling and testing coverage. The caching strategy ensures optimal performance while the modular design allows for easy extension and maintenance.

**Recommendation:** Proceed with implementation following the phased approach outlined above, with particular attention to testing and performance optimization in Phase 2.
